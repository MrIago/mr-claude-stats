#!/bin/bash
# mr-claude-stats - Accurate statusline for Claude Code CLI
# https://github.com/MrIago/mr-claude-stats

VERSION="1.0.2"

# Handle --help and --version
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
  cat << 'EOF'
mr-claude-stats - The most accurate Claude Code statusline

INSTALL:
  npm install -g mr-claude-stats

SETUP:
  Add to ~/.claude/settings.json:

  {
    "statusLine": {
      "type": "command",
      "command": "mr-claude-stats"
    }
  }

WHAT IT SHOWS:
  ████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
  Opus 4.5                                     130k/200k (65%)

REQUIREMENTS:
  - jq (JSON processor)
  - bash

MORE INFO:
  https://github.com/MrIago/mr-claude-stats
EOF
  exit 0
fi

if [[ "$1" == "--version" || "$1" == "-v" ]]; then
  echo "mr-claude-stats v$VERSION"
  exit 0
fi

export LC_NUMERIC=C
input=$(cat)

MODEL=$(echo "$input" | jq -r '.model.display_name // "Claude"')
CONTEXT=$(echo "$input" | jq -r '.context_window.context_window_size // 200000')
TRANSCRIPT=$(echo "$input" | jq -r '.transcript_path // ""')

# Cache para persistir último valor conhecido
CACHE_FILE="/tmp/statusline_cache_${SESSION_ID:-default}"
SESSION_ID=$(echo "$input" | jq -r '.session_id // "default"')
CACHE_FILE="/tmp/statusline_cache_${SESSION_ID}"

# Ler usage do último request com usage válido no transcript
TOTAL=0
if [ -n "$TRANSCRIPT" ] && [ -f "$TRANSCRIPT" ]; then
  # Buscar último entry que tem usage (ignorar comandos locais sem usage)
  # Usar tail -r no Mac, tac no Linux
  if command -v tac &>/dev/null; then
    LAST_USAGE=$(tac "$TRANSCRIPT" 2>/dev/null | jq -s '[.[] | select(.usage != null or .message.usage != null)] | .[0] | .usage // .message.usage' 2>/dev/null)
  else
    LAST_USAGE=$(tail -r "$TRANSCRIPT" 2>/dev/null | jq -s '[.[] | select(.usage != null or .message.usage != null)] | .[0] | .usage // .message.usage' 2>/dev/null)
  fi
  if [ -n "$LAST_USAGE" ] && [ "$LAST_USAGE" != "null" ]; then
    INPUT_T=$(echo "$LAST_USAGE" | jq -r '.input_tokens // 0')
    CACHE_CREATE=$(echo "$LAST_USAGE" | jq -r '.cache_creation_input_tokens // 0')
    CACHE_READ=$(echo "$LAST_USAGE" | jq -r '.cache_read_input_tokens // 0')
    OUTPUT_T=$(echo "$LAST_USAGE" | jq -r '.output_tokens // 0')
    # Total = input atual + cache + output + buffer de autocompact (45k)
    MESSAGES=$((INPUT_T + CACHE_CREATE + CACHE_READ + OUTPUT_T))
    AUTOCOMPACT_BUFFER=45000
    TOTAL=$((MESSAGES + AUTOCOMPACT_BUFFER))
    # Salvar no cache
    echo "$TOTAL" > "$CACHE_FILE"
  fi
fi

# Se não encontrou, usar cache anterior
if [ "$TOTAL" -eq 0 ] && [ -f "$CACHE_FILE" ]; then
  TOTAL=$(cat "$CACHE_FILE" 2>/dev/null || echo 0)
fi

# Se não tem dados, mostrar só o modelo
if [ "$TOTAL" -eq 0 ]; then
  echo -e "\033[38;5;117m${MODEL}\033[0m"
  exit 0
fi
PERCENT=$((TOTAL * 100 / CONTEXT))

# Cores ANSI (pastel)
BLUE='\033[38;5;117m'
GREEN='\033[38;5;114m'
YELLOW='\033[38;5;186m'
ORANGE='\033[38;5;216m'
RED='\033[38;5;174m'
GRAY='\033[38;5;242m'
RESET='\033[0m'


# Formatar tokens
format_tokens() {
  local n=$1
  if [ $n -ge 1000 ]; then
    echo "$((n / 1000))k"
  else
    echo "$n"
  fi
}

TOTAL_FMT=$(format_tokens $TOTAL)
CONTEXT_FMT=$(format_tokens $CONTEXT)

# Barra de 60 caracteres com gradiente
BAR_SIZE=60
FILLED=$((PERCENT * BAR_SIZE / 100))
EMPTY=$((BAR_SIZE - FILLED))

# Thresholds para cores (em chars)
T1=$((BAR_SIZE * 25 / 100))  # 25% = 15 chars
T2=$((BAR_SIZE * 50 / 100))  # 50% = 30 chars
T3=$((BAR_SIZE * 75 / 100))  # 75% = 45 chars

BAR=""
for ((i=0; i<FILLED; i++)); do
  if [ $i -lt $T1 ]; then
    BAR+="${GREEN}█"
  elif [ $i -lt $T2 ]; then
    BAR+="${YELLOW}█"
  elif [ $i -lt $T3 ]; then
    BAR+="${ORANGE}█"
  else
    BAR+="${RED}█"
  fi
done
BAR+="${GRAY}"
for ((i=0; i<EMPTY; i++)); do BAR+="░"; done
BAR+="${RESET}"

# Cor do texto baseada no percentual
if [ $PERCENT -lt 25 ]; then
  TEXT_COLOR=$GREEN
elif [ $PERCENT -lt 50 ]; then
  TEXT_COLOR=$YELLOW
elif [ $PERCENT -lt 75 ]; then
  TEXT_COLOR=$ORANGE
else
  TEXT_COLOR=$RED
fi

# Info formatada com largura fixa (18 chars total)
RIGHT=$(printf "%18s" "${TOTAL_FMT}/${CONTEXT_FMT} (${PERCENT}%)")

# Row 1: Barra
echo -e "$BAR"
# Row 2: Model (azul) esquerda, tokens (cor) direita
echo -e "${BLUE}$(printf "%-42s" "$MODEL")${RESET}${TEXT_COLOR}${RIGHT}${RESET}"
